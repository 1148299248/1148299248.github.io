<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pro Git</title>
      <link href="/2020/03/09/Pro-Git/"/>
      <url>/2020/03/09/Pro-Git/</url>
      
        <content type="html"><![CDATA[<h3 id="《Pro-Git》"><a href="#《Pro-Git》" class="headerlink" title="《Pro Git》"></a>《Pro Git》</h3><a id="more"></a><hr><h4 id="一）Git-amp-其他分布式版本控制系统-的区别"><a href="#一）Git-amp-其他分布式版本控制系统-的区别" class="headerlink" title="(一）Git &amp; 其他分布式版本控制系统 的区别"></a>(一）Git &amp; 其他分布式版本控制系统 的区别</h4><ol><li><p>其他分布式版本控制系统比较关注文件内容的具体差异（如每次记录有哪些文件作了更新，以及更新了什么内容），有点类似Redis的AOF备份；而Git关注的是文件数据的整体是否发生改变，不保存前后变化的差异数据，类似Redis的RDB备份 —— 事实上，Git会把变化的文件作快照（snapshot）之后，记录在一个微型的文件系统中，每次提交更新后，它会纵览所有文件的指纹信息并对文件作一快照，然后保存一个指向该快照的索引，如果文件没有变化则会沿用上次的索引。</p><blockquote><p>快照（snapshot）：<br>Snapshot是关于制定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间节点的映像（一般会维系一个映射表和源数据进行对应）。<br>指纹信息（fingerprint）：<br>Git的指纹信息是一个对文件快照进行SHA-1哈希算法校验和计算得到的40位十六进制字符串，以此来作为Git的文件索引。</p></blockquote></li><li><p>其他分布式版本控制系统中，基本上所有操作都需要连接网络；而Git中<strong>绝大多数操作都可以在本地完成</strong>，不需要网络 —— Git的所有文件历史记录都会保存在本地，而不是只保存在远程仓库中。</p></li></ol><hr><h4 id="（二）Git的-工作区域-amp-文件状态"><a href="#（二）Git的-工作区域-amp-文件状态" class="headerlink" title="（二）Git的 工作区域 &amp; 文件状态"></a>（二）Git的 工作区域 &amp; 文件状态</h4><p><img src="https://i.bmp.ovh/imgs/2019/06/e3968f45a2686fce.png" alt></p><h5 id="工作区域"><a href="#工作区域" class="headerlink" title="工作区域"></a>工作区域</h5><ol><li>工作目录（working directory）</li><li>暂存区域（staging area）：<code>git add</code></li><li>本地仓库（git repository）：<code>git commit</code><h5 id="文件状态"><a href="#文件状态" class="headerlink" title="文件状态"></a>文件状态</h5></li><li>已修改（modified）：在工作目录<code>（working directory）</code>做出了修改、但还未通过git add暂存到暂存区域<code>（staging area）</code>的文件。</li><li>已暂存（staged）：通过<code>git add</code>暂存到暂存区域<code>（staging area）</code>的文件。</li><li>已提交（commited）：在暂存区域<code>（staging area）</code>通过<code>git commit</code>提交到本地仓库<code>（git repository）</code>的文件。</li></ol><hr><h4 id="（三）Git命令"><a href="#（三）Git命令" class="headerlink" title="（三）Git命令"></a>（三）Git命令</h4><h5 id="1-git-help-help-man：获取帮助"><a href="#1-git-help-help-man：获取帮助" class="headerlink" title="1. git help/--help/man：获取帮助"></a>1. <code>git help/--help/man</code>：获取帮助</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 使用git command格式</span><br><span class="line">git help &lt;command&gt;</span><br><span class="line">git &lt;command&gt; --help</span><br><span class="line"></span><br><span class="line"># 使用git-command格式</span><br><span class="line">man git-command</span><br></pre></td></tr></table></figure><hr><h5 id="2-git-config-global：配置"><a href="#2-git-config-global：配置" class="headerlink" title="2. git config --global：配置"></a>2. <code>git config --global</code>：配置</h5><p>一般来说，只有初次使用Git时才需要配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 配置用户名和邮箱</span><br><span class="line">git config --global user.name &quot;DragonBaby308&quot;</span><br><span class="line">git config --global user.email dragonbabay308.codeman@gmail.com</span><br><span class="line"></span><br><span class="line"># 查看配置信息</span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"># 设置别名</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br><span class="line">git config --global alias.unstage &#39;reset HEAD --&#39;</span><br><span class="line">git config --global alias.last &#39;log -1 HEAD&#39;</span><br></pre></td></tr></table></figure><p>如果修改了账号密码，那么重新对远程库进行操作时就会报错：</p><blockquote><p><code>remote: HTTP Basic: Access denied fatal:Authentication failed for xxx</code></p></blockquote><p>这时候需要更改账号密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除原有的账号密码，这样重新git clone时就会要求你重新输入账号密码</span><br><span class="line">git config --system --unset credential.helper</span><br></pre></td></tr></table></figure><hr><h5 id="3-git-init：初始化新仓库"><a href="#3-git-init：初始化新仓库" class="headerlink" title="3. git init：初始化新仓库"></a>3. <code>git init</code>：初始化新仓库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 初始化新仓库</span><br><span class="line">git init</span><br></pre></td></tr></table></figure><hr><h5 id="4-git-add：将已修改文件添加到暂存区"><a href="#4-git-add：将已修改文件添加到暂存区" class="headerlink" title="4.git add：将已修改文件添加到暂存区"></a>4.<code>git add</code>：将已修改文件添加到暂存区</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 将已修改(modified)文件提交到staging area暂存区</span><br><span class="line">git add .</span><br><span class="line">git add *.c</span><br><span class="line">git add README</span><br></pre></td></tr></table></figure><hr><h5 id="5-git-commit：将已暂存文件提交到本地仓库"><a href="#5-git-commit：将已暂存文件提交到本地仓库" class="headerlink" title="5. git commit：将已暂存文件提交到本地仓库"></a>5. <code>git commit</code>：将已暂存文件提交到本地仓库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 将已暂存(staged)文件提交到git repository本地仓库</span><br><span class="line">git commit -m &quot;MESSAGE&quot;</span><br><span class="line"></span><br><span class="line"># 跳过git-add直接提交</span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"># 修改上一次提交</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><hr><h5 id="6-git-clone：从现有仓库复制"><a href="#6-git-clone：从现有仓库复制" class="headerlink" title="6.git clone：从现有仓库复制"></a>6.<code>git clone</code>：从现有仓库复制</h5><p>Git 支持许多数据传输协议： <code>git:// 、 http(s)</code>:// 或者 <code>user@server:/path.git</code> 表示的 SSH 传输协议。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 复制到当前目录</span><br><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git</span><br><span class="line"># 复制到指定目录</span><br><span class="line">git clone git:&#x2F;&#x2F;github.com&#x2F;schacon&#x2F;grit.git  mygrit</span><br></pre></td></tr></table></figure><hr><h5 id="7-git-status：查看当前工作区状态"><a href="#7-git-status：查看当前工作区状态" class="headerlink" title="7.git status：查看当前工作区状态"></a>7.<code>git status</code>：查看当前工作区状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前目录所有文件状态</span><br><span class="line">git status</span><br></pre></td></tr></table></figure><hr><h5 id="8-git-diff：查看具体修改"><a href="#8-git-diff：查看具体修改" class="headerlink" title="8. git diff：查看具体修改"></a>8. <code>git diff</code>：查看具体修改</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># git diff不带参数：比较的是工作目录working directory和暂存区域staged area之间的差异</span><br><span class="line"># —— 也就是修改(modifed)后还没有被暂存(staged)的变化内容</span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"># 比较已暂存(staged)和上次提交(commited)的快照之间的差异</span><br><span class="line">git diff --cached</span><br><span class="line">git diff --staged</span><br></pre></td></tr></table></figure><hr><h5 id="9-git-rm：移除文件"><a href="#9-git-rm：移除文件" class="headerlink" title="9.git rm：移除文件"></a>9.<code>git rm</code>：移除文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 从暂存区移除</span><br><span class="line">git rm filename</span><br><span class="line"></span><br><span class="line"># 从本地仓库移除</span><br><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure><hr><h5 id="10-git-mv：改名"><a href="#10-git-mv：改名" class="headerlink" title="10. git mv：改名"></a>10. <code>git mv</code>：改名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将file1改名为file2</span><br><span class="line">git mv file1 file2</span><br></pre></td></tr></table></figure><hr><h5 id="11-git-log：查看提交历史"><a href="#11-git-log：查看提交历史" class="headerlink" title="11. git log：查看提交历史"></a>11. <code>git log</code>：查看提交历史</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不带参数：按提交时间列出，最近的更新在最上面</span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"># -p      展开显示每次提交内容的差异</span><br><span class="line"># -数字   只显示最近的对应次数的更新</span><br><span class="line">git log -p -number</span><br><span class="line"></span><br><span class="line"># --word-diff 显示单词层面上的对比</span><br><span class="line">git log -p -2 --word-diff</span><br></pre></td></tr></table></figure><hr><h5 id="12-撤销操作"><a href="#12-撤销操作" class="headerlink" title="12. 撤销操作"></a>12. 撤销操作</h5><p>有些撤销操作是不可逆的，所以一定要小心，一旦失误则有可能丢失部分工作成果。</p><h6 id="（1）git-commit-–amend：修改上一次提交"><a href="#（1）git-commit-–amend：修改上一次提交" class="headerlink" title="（1）git commit –amend：修改上一次提交"></a>（1）git commit –amend：修改上一次提交</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commmit -m &quot;initial commit&quot;</span><br><span class="line"># 将忘记提交的文件加入暂存区</span><br><span class="line">git add forgotten_file</span><br><span class="line"># 覆盖上一次提交，两次commit只产生一个结果</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h6 id="（2）git-reset：删除上一次添加到暂存区的文件"><a href="#（2）git-reset：删除上一次添加到暂存区的文件" class="headerlink" title="（2）git reset：删除上一次添加到暂存区的文件"></a>（2）git reset：删除上一次添加到暂存区的文件</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 取消文件暂存</span><br><span class="line">git reset HEAD filename</span><br></pre></td></tr></table></figure><h6 id="（3）git-checkout：取消对文件的修改"><a href="#（3）git-checkout：取消对文件的修改" class="headerlink" title="（3）git checkout：取消对文件的修改"></a>（3）git checkout：取消对文件的修改</h6><p>这个命令很危险，Git将不会保留你对文件做的所有修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 取消对文件的修改</span><br><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><hr><h5 id="13-远程仓库"><a href="#13-远程仓库" class="headerlink" title="13. 远程仓库"></a>13. 远程仓库</h5><h6 id="（1）git-remote：查看当前远程库"><a href="#（1）git-remote：查看当前远程库" class="headerlink" title="（1）git remote：查看当前远程库"></a>（1）<code>git remote</code>：查看当前远程库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前远程库的简短名字shortname</span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"># 查看当前远程库的详细信息（克隆地址） --verbose</span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h6 id="（2）git-remote-add：添加远程库"><a href="#（2）git-remote-add：添加远程库" class="headerlink" title="（2）git remote add：添加远程库"></a>（2）<code>git remote add</code>：添加远程库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 远程库名origin，URL为git:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit.git</span><br><span class="line">git remote add origin git:&#x2F;&#x2F;github.com&#x2F;paulboone&#x2F;ticgit.git</span><br></pre></td></tr></table></figure><h6 id="（3）git-fetch-git-pull：从远程仓库抓取数据"><a href="#（3）git-fetch-git-pull：从远程仓库抓取数据" class="headerlink" title="（3）git fetch/git pull：从远程仓库抓取数据"></a>（3）<code>git fetch/git pull</code>：从远程仓库抓取数据</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 从远程仓库中抓取本地仓库没有的数据，运行后可在本地访问远程库所有分支</span><br><span class="line">git fetch origin</span><br><span class="line"></span><br><span class="line"># 抓取远程仓库的特定分支</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h6 id="（4）git-push：推送数据到远程库"><a href="#（4）git-push：推送数据到远程库" class="headerlink" title="（4）git push：推送数据到远程库"></a>（4）<code>git push</code>：推送数据到远程库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将本地的master分支，推送到远程库origin</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h6 id="（5）git-remote-show：查看某个特定远程库的信息"><a href="#（5）git-remote-show：查看某个特定远程库的信息" class="headerlink" title="（5）git remote show：查看某个特定远程库的信息"></a>（5）<code>git remote show</code>：查看某个特定远程库的信息</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看某个特定远程库的信息</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h6 id="（6）git-remote-rename：重命名远程库"><a href="#（6）git-remote-rename：重命名远程库" class="headerlink" title="（6）git remote rename：重命名远程库"></a>（6）<code>git remote rename</code>：重命名远程库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 修改远程库名称</span><br><span class="line">git remote rename origin neworigin</span><br></pre></td></tr></table></figure><h6 id="（7）git-remote-rm：删除远程库"><a href="#（7）git-remote-rm：删除远程库" class="headerlink" title="（7）git remote rm：删除远程库"></a>（7）<code>git remote rm</code>：删除远程库</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除远程库</span><br><span class="line">git remote rm neworigin</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springcloud</title>
      <link href="/2020/02/18/springcloud/"/>
      <url>/2020/02/18/springcloud/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><p><code>Spring Cloud</code>可以将大的项目拆分成若干个小的模块，每一个模块都是一个独立的子系统，所有子模块组合起来完成系统总功能。</p><a id="more"></a><p>基础功能：<br>    1.服务治理:<code>Spring Cloud Eureka</code><br>    2.客户端负载均衡：<code>Spring Cloud Ribbon</code><br>    3.服务器容错保护：<code>Spring Cloud Hystrix</code><br>    4.声明式服务调用：<code>Spring Cloud Feign</code><br>    5.API网关服务：<code>Spring Cloud Zuul</code><br>    6.分布式配置中心：<code>Spring Cloud Config</code><br>高级功能：<br>    1.消息总线：<code>Spring Cloud Bus</code><br>    2.消息驱动的微服务：<code>Spring Cloud Stream</code><br>    3.分布式服务跟踪：<code>Spring Cloud Sleuth</code></p><hr><h3 id="Spring-Cloud技术栈"><a href="#Spring-Cloud技术栈" class="headerlink" title="Spring Cloud技术栈"></a>Spring Cloud技术栈</h3><p>消息中心：<code>Stream</code>、<code>Bus</code><br>配置中心：<code>Git</code>、<code>ZooKeeper</code><br>授权认证中心:<code>Security</code>、<code>JWT</code>、<code>Oauto</code><br>缓存中心：<code>Data</code><br>文档中心：<code>Swagger</code><br>服务注册与发现：<code>Eureka</code>、<code>Consul</code>、<code>Zookeeper</code><br>网关路由:<code>Zuul</code>、<code>Gateway</code><br>服务调用:<code>Ribbon</code>、<code>Feign</code>、<code>Hystrix</code><br>监控:<code>Actuctor</code>、<code>Admin</code><br>链路追踪:<code>Sleuth</code>、<code>Zipkin</code></p><blockquote><p>Spring Cloud 与 Dubbo 的区别：<br><strong>服务注册：Dubbo使用的ZooKeeper，注重数据一致性，抛弃高可用性；Spring Cloud使用的Eureka，注重高可用性，存在自我保护机制，允许旧数据；<br>服务调用：Dubbo使用RPC；Spring Cloud使用REST API；</strong><br>服务监控：Dubbo使用Dubbo-monitor，<strong>由Provider和Consumer统计服务调用成功次数、失败次数、平均响应时间，然后实时提交到监控中心；</strong>Spring Cloud使用Spring Boot Admin；<br>断路器：Dubbo无；Spring Cloud Hystrix；<br>服务网关：Dubbo无；Spring Cloud Zuul；<br>分布式配置：Dubbo无；Spring Cloud Config；<br>服务跟踪：Dubbo无；Spring Cloud Sleuth；<br>消息总线：Dubbo无；Spring Cloud Bus；<br>数据流：Dubbo无；Spring Cloud Stream；<br>批量任务：Dubbo无；Spring Cloud Task</p></blockquote><hr><h3 id="IDEA中Spring-Cloud项目的创建"><a href="#IDEA中Spring-Cloud项目的创建" class="headerlink" title="IDEA中Spring Cloud项目的创建"></a>IDEA中Spring Cloud项目的创建</h3><p>未完待续………………….</p>]]></content>
      
      
      <categories>
          
          <category> spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ高可用性实现原理</title>
      <link href="/2020/01/22/RocketMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2020/01/22/RocketMQ%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><h5 id="（一）特性"><a href="#（一）特性" class="headerlink" title="（一）特性"></a>（一）特性</h5><ol><li>支持Pub/Sub和P2P两种消息模型</li><li>可靠的FIFO队列，严格保证消息有序</li><li>支持Pull/Push两种消息模式</li><li>单一队列百万消息堆积能力</li><li>支持多种消息协议，如JMS</li><li>分布式、高可用</li><li>Docker镜像云集群部署</li><li>功能丰富的Dashboard<a id="more"></a></li></ol><hr><h5 id="（二）术语"><a href="#（二）术语" class="headerlink" title="（二）术语"></a>（二）术语</h5><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1rdyvPXXXXXcBapXXXXXXXXXX" alt></p><ul><li>Producer：生产者将消息发送到队列</li><li>Producer Group：发送同一类消息的生产者组</li><li>Consumer：消费者从队列消费消息</li><li>Consumer Group：消费同一类消息的消费者组</li><li>Topic：<strong>主题是消息的逻辑分类，主要用于区分业务模块，比如购物车、订单……</strong></li><li>Tag：<strong>标签是对主题的进一步细分，在相同的业务模块内引入标签标记不同用途的消息</strong></li><li>Message：消息必须指定Topic，可选Tag以便消费端根据Tag过滤消息</li><li>Broker：<strong>相当于MQ，用于接收生产者的消息，存储消息，并为消费者拉取消息做好准备</strong></li><li>Name Server：<strong>为Producer和Consumer提供路由信息</strong></li></ul><hr><h5 id="三）高可用架构"><a href="#三）高可用架构" class="headerlink" title="(三）高可用架构"></a>(三）高可用架构</h5><p><img src="https://dragonbaby308.oss-cn-hangzhou.aliyuncs.com/mq/rocketMq-ha.webp" alt></p><ol><li>Name Server集群：<strong>提供轻量级的服务发现和路由。每个Name Server记录完整的路由信息，提供等效的读写服务，并支持快速存储扩展。</strong><blockquote><p>Name Server之间<strong>互不通信，会存在数据不一致的情况。</strong><br>RocketMQ为什么使用Name Server而非ZooKeeper？<br><strong>因为ZooKeeper为了保证强一致性会放弃一段时间内的可用 性</strong>，而Name Server作为注册中心只是为了发现组件地址，对一致性要求不高。</p></blockquote></li><li>Broker集群：</li></ol><ul><li>提供轻量级的Topic和Queue机制来处理消息存储；</li><li>同时支持Pull/Push模式；</li><li>支持多Master多Slave异步复制/同步双写机制，防止单点故障；</li><li>每一个Master和其Slave之间通过主从复制进行数据同步；</li><li>每个Broker与Name Server集群中的所有节点建立长连接，定时将Topic信息注册到所有Name Server</li></ul><ol start="3"><li>Producer Group集群：</li></ol><ul><li>Producer与Name Server中的任意一个节点建立长连接，定是从Name Server获取Topic路由信息<blockquote><p>请参考<code>ZK</code>或<code>MySQL</code>的集群，<strong>凡是涉及到“改数据”的都只会连接Master，即只连接写节点，其他节点只是同步复制Master</strong>，这样可以保证数据一致性的实现更简单。</p></blockquote></li></ul><ol start="4"><li>Consumer Group集群：可以和Broker Master或Broker Slave建立长连接，获取消息；同一个Consumer Group下的多个Consumer<strong>均摊</strong>消费消息，如果设置为<strong>广播</strong>模式，每个Consumer都消费<strong>全量数据</strong>。</li></ol><hr><h5 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h5><h6 id="1-消息优先级"><a href="#1-消息优先级" class="headerlink" title="1.消息优先级"></a>1.消息优先级</h6><p><strong>优先级是指在一个MQ中，每条消息都有自己的优先级，一般用整数描述，优先级高的消息先投递（由于MQ采用的是FIFO队列，所以一般是通过将消息按照优先级排序后再发送）。</strong><br>对于优先级问题可以归结为两类：</p><ol><li>严格的优先级：<strong>优先级用整数表示，投递前按照优先级对消息进行排序，十分耗时。</strong>使用时应该要考虑严格的优先级是否是业务一定需要的，否则不推荐这种。<blockquote><p><code>RocketMQ</code><strong>所有消息都是持久化的，如果按照严格的优先级，对所有消息进行排序，开销会非常大。</strong></p></blockquote></li><li>非严格意义上的优先级：<strong>将优先级划分为高、中、低，每个优先级用不同的Topic表示，RocketMQ采用的就是这种方式，单独配置一个高优先级队列和一个低优先级队列，将不同优先级的消息发送到不同队列。</strong></li></ol><hr><h6 id="2-消息过滤器"><a href="#2-消息过滤器" class="headerlink" title="2.消息过滤器"></a>2.消息过滤器</h6><p>(1)Broker端消息过滤<br>在Broker端，根据Consumer的要求做过滤。</p><blockquote><p><code>RocketMQ</code><strong>支持根据Message Tag进行简单的过滤，也支持按照Message Header/Body做过滤</strong></p></blockquote><ul><li>优点：<strong>减少了对于Consumer无用消息的网络传输</strong></li><li>缺点：<strong>增加了Broker负担，实现相对复杂</strong><br>(2)Consumer端消息过滤</li><li>优点：<strong>可以完全自定义实现</strong></li><li>缺点：<strong>会有很多无用消息要传输到Consumer端</strong></li></ul><hr><h6 id="3-消息持久化"><a href="#3-消息持久化" class="headerlink" title="3.消息持久化"></a>3.消息持久化</h6><p>MQ通常支持的集中消息持久化方式：</p><ol><li>持久化到数据库</li><li>持久化到K/V存储</li><li><strong>文件记录形式持久化，如<code>Kafka、RocketMQ</code></strong><blockquote><p><strong>消息持久化部分的性能直接决定了整个消息中间件的性能</strong>，RocketMQ充分利用了<strong>Linux文件系统内存Cach</strong>e来提高性能。</p></blockquote></li><li>对内存数据做持久化镜像</li></ol><hr><h6 id="4-消息可靠性"><a href="#4-消息可靠性" class="headerlink" title="4.消息可靠性"></a>4.消息可靠性</h6><ol><li>Broker正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器断点，但是可以恢复<blockquote><p>以上4种情况都属于硬件资源可恢复的情况，<strong><code>RocketMQ</code>可以通过消息持久化保证消息不丢失，或者只丢失少部分。<br>如果写入磁盘和返回Consumer ACK这两个操作是同步的，那么可以做到消息完全不丢失；如果是异步的，那么会丢失少部分。</strong></p></blockquote></li></ol><blockquote><p>同步刷盘怎么才能快？<br>1.使用DirectBuffer堆外内存，加快内存拷贝；<br>2.数据和索引分离，通过Offset快速定位，减少I/O随机读写性能损耗<br>5. 机器损坏<br>6. 磁盘损坏<br>5和6属于<strong>单点故障</strong>，一旦发生此单点上的消息全部丢失。<br><code>RocketMQ</code>通过<strong>多Master之间的异步复制</strong>保证99%的消息不会丢失，但是仍有<strong>少量</strong>消息可能丢失。<br>可以通过<strong>同步双写</strong>完全避免<strong>单点故障</strong>，但是<strong>同步双写势必影响性能，只适合对消息可靠性要求非常高的情况，比如Money</strong></p></blockquote><hr><h6 id="5-消息低延迟"><a href="#5-消息低延迟" class="headerlink" title="5.消息低延迟"></a>5.消息低延迟</h6><p>消息到达Broker后，在不堆积的情况下，必须要尽快到达Consumer。可以有两种形式：</p><ol><li>Broker Push</li><li>Consumer Pull：<code>RocketMQ</code><strong>采用的是长轮询Pull，可以保证消息实时性</strong></li></ol><hr><h6 id="6-每个消息必须投递至少一次"><a href="#6-每个消息必须投递至少一次" class="headerlink" title="6.每个消息必须投递至少一次"></a>6.每个消息必须投递至少一次</h6><p><code>RocketMQ Consumer</code><strong>先将消息Pull到本地，消费完成后，才向服务器返回ACK，可以保证每个消息必须投递至少一次。</strong></p><h6 id="7-每个消息只被处理一次"><a href="#7-每个消息只被处理一次" class="headerlink" title="7.每个消息只被处理一次"></a>7.每个消息只被处理一次</h6><p>这个特性是说：</p><ol><li>发送消息阶段，不允许发送重复的消息；</li><li>消费消息阶段，不允许消费重复的消息<br>要在分布式系统中满足以上两点，势必会产生巨大的开销。所以RocketMQ为了追求高性能，没有实现此特性，<strong>而是要求业务上进行去重，也就是保证消费消息的幂等性</strong></li></ol><hr><h6 id="8-Broker-Buffer满了如何处理"><a href="#8-Broker-Buffer满了如何处理" class="headerlink" title="8.Broker Buffer满了如何处理"></a>8.Broker Buffer满了如何处理</h6><p>通常来说Broker Buffer指的是Broker中一个<strong>队列的内存Buffer大小</strong>，这类Buffer通常大小有限，如果Buffer满了可以有拒绝消息、丢弃队首消息等措施，类似线程池的拒绝策略。<br><strong>但是RocketMQ没有内存Buffer的概念，它的队列都是持久化磁盘，数据定期清除；不过RocketMQ使用LinkedBlockingQueue作为消息队列，理论上是无限大，但是可能导致内存泄漏。</strong></p><hr><h6 id="9-回溯消息"><a href="#9-回溯消息" class="headerlink" title="9.回溯消息"></a>9.回溯消息</h6><p>回溯是指Consumer已经消费了的消息，如果业务上需要重新消费，需要支持此功能，RocketMQ的消息都是持久化的，支持通过时间维度进行回溯。</p><h6 id="10-消息堆积"><a href="#10-消息堆积" class="headerlink" title="10.消息堆积"></a>10.消息堆积</h6><ol><li>消息堆积在内存Buffer：消息堆积能力取决于内存Buffer大小；</li><li>消息堆积在持久化存储系统，如磁盘：<strong>当消息不能在内存Cache命中时，要不可避免地访问磁盘，会产生大量的I/O，读I/O的吞吐量直接决定了消息堆积后的访问能力</strong><blockquote><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1Ali2PXXXXXXuXFXXXXXXXXXX" alt><br><code>RocketMQ</code>采用了一种数据和索引分开的存储方式，有效降低I/O销毁。</p></blockquote></li></ol><hr><h6 id="11-分布式事务"><a href="#11-分布式事务" class="headerlink" title="11.分布式事务"></a>11.分布式事务</h6><p>RocketMQ的分布式事务采用的是<strong>二阶段提交（2PA）</strong>：</p><ol><li>2PA在数据存储方面需要KV存储的支持，因为二阶段的提交回滚需要修改消息状态，一定涉及到根据Key查找Message的动作。<blockquote><p>消息回滚了也不会物理删除，只是<strong>逻辑删除</strong></p></blockquote></li><li>RocketMQ在二阶段绕过了KV存储，<strong>直接在一阶段发送Prepared消息时拿到了消息的地址Offset</strong>，二阶段提交回滚时直接通过Offset访问消息，并修改状态。<blockquote><p>缺点：<strong>使用Offset会使得系统的脏页过多</strong></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub上一些有趣的项目【持续更新~】</title>
      <link href="/2020/01/10/GitHub%E4%B8%8A%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%E3%80%91/"/>
      <url>/2020/01/10/GitHub%E4%B8%8A%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE%E3%80%90%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%E3%80%91/</url>
      
        <content type="html"><![CDATA[<h3 id="GitHub上一些有趣的项目"><a href="#GitHub上一些有趣的项目" class="headerlink" title="GitHub上一些有趣的项目"></a>GitHub上一些有趣的项目</h3><a id="more"></a><hr><h4 id="（一）reveal-md：使用-md来做PPT"><a href="#（一）reveal-md：使用-md来做PPT" class="headerlink" title="（一）reveal-md：使用.md来做PPT"></a>（一）reveal-md：使用.md来做PPT</h4><p>详细信息见<a href="https://github.com/webpro/reveal-md" target="_blank" rel="noopener">reveal-md项目地址</a>。<br>相似的还有用HTML做PPT展示的<a href="https://github.com/hakimel/reveal.js" target="_blank" rel="noopener">reveal.js</a>。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>npm install -g reveal-md</p><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><code>reveal-md path/demo.md</code>，其中，<code>path/demo.md</code>是你的<strong>Markdown</strong>文件地址，可以使用本地地址，也可以使用URL。<br>使用如下的<strong>Markdown</strong>文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Title</span><br><span class="line"></span><br><span class="line">* Point 1</span><br><span class="line">* Point 2</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## Second slide</span><br><span class="line"></span><br><span class="line">&gt; Best quote ever.</span><br><span class="line"></span><br><span class="line">Note: speaker notes FTW!</span><br></pre></td></tr></table></figure><p>效果如图：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3id3iiwqmg31gv0ojq8z.jpg" alt></p><h5 id="通过solarized主题使用"><a href="#通过solarized主题使用" class="headerlink" title="通过solarized主题使用"></a>通过<code>solarized</code>主题使用</h5><p><code>reveal-md path/demo.md --theme solarized</code><br>效果如图：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3id43ocxkg31gv0ojq9l.jpg" alt></p><hr><h4 id="（二）Logoly-Pro：不正经的Logo生成器"><a href="#（二）Logoly-Pro：不正经的Logo生成器" class="headerlink" title="（二）Logoly.Pro：不正经的Logo生成器"></a>（二）Logoly.Pro：不正经的Logo生成器</h4><p>该项目可以根据你输入的文字创建PornHub风格的Logo（<del>知道PornHub是什么的坏孩子请面壁思过</del>）。<br><a href="https://github.com/bestony/logoly" target="_blank" rel="noopener">GitHub仓库地址</a><br><a href="https://logoly.pro/#/" target="_blank" rel="noopener">Logoly.Pro在线版</a><br>比如，我输入DragonBaby，然后点击Export：<br><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5nspomkv7j31k40rk42d.jpg" alt></p><hr><h4 id="（三）emoji-mosaic：将图片转成emoji标签马赛克"><a href="#（三）emoji-mosaic：将图片转成emoji标签马赛克" class="headerlink" title="（三）emoji-mosaic：将图片转成emoji标签马赛克"></a>（三）<code>emoji-mosaic</code>：将图片转成emoji标签马赛克</h4><p><a href="https://github.com/ericandrewlewis/emoji-mosaic" target="_blank" rel="noopener">GitHub仓库地址</a><br><a href="http://ericandrewlewis.github.io/emoji-mosaic/" target="_blank" rel="noopener">emoji-mosaic</a> 在线版（有一说一，这个在线版属实简约嗷……）<br>效果图如下：<br>~<a href="https://tva4.sinaimg.cn/large/007DFXDhly1g5nt2rci0vj30u012ob29.jpg" target="_blank" rel="noopener"></a></p><hr><h4 id="（四）gifi：在你执行npm-install时放gif图"><a href="#（四）gifi：在你执行npm-install时放gif图" class="headerlink" title="（四）gifi：在你执行npm install时放gif图"></a>（四）<code>gifi</code>：在你执行<code>npm install</code>时放gif图</h4><ul><li><a href="https://github.com/vadimdemedes/gifi" target="_blank" rel="noopener">gifi</a>：注意它不是在你的终端播放，而是浏览器打开gif图播放，所以酌情安装。</li></ul><hr><h4 id="（五）bash-insulter：在输入错误bash命令时进行羞辱的脚本"><a href="#（五）bash-insulter：在输入错误bash命令时进行羞辱的脚本" class="headerlink" title="（五）bash-insulter：在输入错误bash命令时进行羞辱的脚本"></a>（五）bash-insulter：在输入错误bash命令时进行羞辱的脚本</h4><p><a href="https://github.com/hkbakke/bash-insulter" target="_blank" rel="noopener">Github项目地址</a><br>首先你服务器需要安装了<code>Git</code>。<br>通过<code>git clone https://github.com/hkbakke/bash-insulter bash-insulter</code>命令克隆项目到本地。</p><h5 id="将下载内容移动到-etc目录下"><a href="#将下载内容移动到-etc目录下" class="headerlink" title="将下载内容移动到/etc目录下"></a>将下载内容移动到/etc目录下</h5><p><code>cp bash-insulter/src/bash.command-not-found /etc/</code></p><h5 id="修改-etc-bash-bashrc文件"><a href="#修改-etc-bash-bashrc文件" class="headerlink" title="修改/etc/bash.bashrc文件"></a>修改/etc/bash.bashrc文件</h5><p><code>vim /etc/bash.bashrc</code>打开文件，在末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Bash Insulter</span><br><span class="line">if [ -f &#x2F;etc&#x2F;bash.command-not-found ]; then</span><br><span class="line"> . &#x2F;etc&#x2F;bash.command-not-found</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h5 id="source-etc-bash-bashrc-使修改生效"><a href="#source-etc-bash-bashrc-使修改生效" class="headerlink" title="source /etc/bash.bashrc 使修改生效"></a>source /etc/bash.bashrc 使修改生效</h5><p><code>source /etc/bash.bashrc</code><br>生效后，输入错误的bash命令就会被狠狠羞辱：<br><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g4r1xhe10yj30np0eyq3p.jpg" alt></p><hr><h4 id="六）the-fuck：输入错误bash命令后通过fuck进行修正"><a href="#六）the-fuck：输入错误bash命令后通过fuck进行修正" class="headerlink" title="(六）the-fuck：输入错误bash命令后通过fuck进行修正"></a>(六）the-fuck：输入错误bash命令后通过fuck进行修正</h4><p><a href="https://github.com/nvbn/thefuck" target="_blank" rel="noopener">the-fuck项目地址</a></p><ul><li><code>Mac</code>下通过<code>brew install thefuck</code>安装</li><li><code>vim ~/.bashrc</code>，修改：</li></ul><p><code>eval &quot;$(thefuck --alias)&quot;</code></p><ul><li>source ~/.bashrc使之生效，输入错误bash命令后通过fuck命令即可进行修正，如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(base) bogon:~ dragonbaby308$ git brach</span><br><span class="line">git: &#39;brach&#39; is not a git command. See &#39;git --help&#39;.</span><br><span class="line"></span><br><span class="line">The most similar command is</span><br><span class="line">branch</span><br><span class="line">(base) bogon:~ dragonbaby308$ fuck</span><br><span class="line">git branch [enter&#x2F;↑&#x2F;↓&#x2F;ctrl+c]</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="（七）12306抢票"><a href="#（七）12306抢票" class="headerlink" title="（七）12306抢票"></a>（七）12306抢票</h4><ul><li><a href="https://github.com/pjialin/py12306" target="_blank" rel="noopener">https://github.com/pjialin/py12306</a><blockquote><p>未测试。</p></blockquote></li></ul><hr><h4 id="（八）变声器"><a href="#（八）变声器" class="headerlink" title="（八）变声器"></a>（八）变声器</h4><ul><li><a href="https://github.com/CorentinJ/Real-Time-Voice-Cloning" target="_blank" rel="noopener">变声器</a><blockquote><p>未测试</p></blockquote></li></ul><hr><h4 id="（九）狗屁不通文章生成器"><a href="#（九）狗屁不通文章生成器" class="headerlink" title="（九）狗屁不通文章生成器"></a>（九）狗屁不通文章生成器</h4><ul><li><a href="https://github.com/menzi11/BullshitGenerator" target="_blank" rel="noopener">狗屁不通文章生成器-GitHub地址</a></li><li><a href="https://suulnnka.github.io/BullshitGenerator/index.html" target="_blank" rel="noopener">狗屁不通文章生成器-网页版</a></li></ul><hr><h4 id="（十）996-amp-955"><a href="#（十）996-amp-955" class="headerlink" title="（十）996 &amp; 955"></a>（十）996 &amp; 955</h4><ul><li><a href="https://github.com/996icu/996.ICU/blob/master/README_CN.md" target="_blank" rel="noopener">996.ICU</a></li><li><a href="https://github.com/formulahendry/955.WLB" target="_blank" rel="noopener">995.WLB</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot2.x</title>
      <link href="/2019/12/05/springboot2-x/"/>
      <url>/2019/12/05/springboot2-x/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Boot-2-x"><a href="#Spring-Boot-2-x" class="headerlink" title="Spring Boot 2.x"></a>Spring Boot 2.x</h3><p><img src="http://dingyue.nosdn.127.net/4GuZVKxvUg3vzLjjVKTanAINH=rMW9uWVVs0cIO2Q50BH1539255606511compressflag.jpg" alt></p><a id="more"></a><hr><h4 id="（一）设计目的"><a href="#（一）设计目的" class="headerlink" title="（一）设计目的"></a>（一）设计目的</h4><ul><li>简化<code>Spring</code>应用程序的初始搭建和开发过程</li></ul><hr><h4 id="（二）设计理念"><a href="#（二）设计理念" class="headerlink" title="（二）设计理念"></a>（二）设计理念</h4><ul><li>约定优于配置（Convention Over Configuration）</li></ul><hr><h4 id="（三）特性"><a href="#（三）特性" class="headerlink" title="（三）特性"></a>（三）特性</h4><blockquote><p>详细情况，见<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/" target="_blank" rel="noopener">《Spring Boot官方文档》</a></p></blockquote><h5 id="【1】SpringApplication"><a href="#【1】SpringApplication" class="headerlink" title="【1】SpringApplication"></a>【1】SpringApplication</h5><h6 id="（1）控制台日志"><a href="#（1）控制台日志" class="headerlink" title="（1）控制台日志"></a>（1）控制台日志</h6><p>控制台默认只显示<code>INFO</code>级别的日志，如果需要查看启动失败时具体报错，可以设置为<code>DEBUG</code>级别。或者通过<code>java -jar xxx.jar --debug</code>启动</p><h6 id="（2）自定义Banner"><a href="#（2）自定义Banner" class="headerlink" title="（2）自定义Banner"></a>（2）自定义Banner</h6><ol><li>将<code>banner.txt</code>添加到classpath</li><li>如果想自定义<code>banner.txt</code>文件位置，可以在<code>application.properties</code>添加<code>spring.banner.location</code>属性；如果文件编码非<code>UTF-8</code>，可以通过<code>spring.banner.charset</code>设置</li><li>如果想通过<code>banner.gif/banner.jpg/banner.png</code>设置，可以通过<code>spring.banner.image.location</code>设置</li></ol><h6 id="（3）事件-amp-监听器"><a href="#（3）事件-amp-监听器" class="headerlink" title="（3）事件 &amp; 监听器"></a>（3）事件 &amp; 监听器</h6><p>由于有些事件在<code>ApplicationContext</code>创建前就被触发，所以不能用<code>@Bean</code>注册，需要使用<code>SpringApplication.addListeners(...)</code>设置监听器。<br>程序运行时，事件发送的顺序：</p><ol><li><code>ApplicationStartingEvent</code>：在运行开始时、但在任何处理（除了监听器和初始化器注册）之前发送</li><li><code>ApplicationEnvironmentPreparedEvent</code>：在已知要在上下文中使用的<code>Environment</code>、但在上下文被创建之前发送 </li><li><code>ApplicationPreparedEvent</code>：在Bean定义<code>（BeanDefinition）</code>被加载之后、<code>refresh()</code>开始之前发送</li><li><code>ApplicationStartedEvent</code>：上下文被刷新<code>（refresh()）</code>之后、<code>ApplicationRunner/CommandLineRunner</code>被调用之前发送</li><li><code>ApplicationStartedEvent</code>：上下文被刷新<code>（refresh()）</code>之后、<code>ApplicationRunner/CommandLineRunner</code>被调用之前发送</li><li><code>ApplicationFailedEvent</code>：启动异常时发送</li></ol><h6 id="4-网络环境（ApplicationContext）"><a href="#4-网络环境（ApplicationContext）" class="headerlink" title="(4)网络环境（ApplicationContext）"></a>(4)网络环境（<code>ApplicationContext</code>）</h6><p><code>SpringApplication</code>会尝试替你创建正确类型的<code>ApplicationContext</code>，它的算法很简单：</p><ol><li>如果存在<code>Spring MVC</code>：创建<code>AnnotationConfigServletWebServerApplicationContext</code></li><li>如果存在<code>Spring WebFlux</code>、不存在<code>Spring MVC</code>：创建<code>AnnotationConfigReactiveWebServerApplicationContext</code></li><li>其他情况：创建<code>AnnotationConfigApplicationContext</code></li><li>通过调用<code>setApplicationContextClass(...)</code>可以完全控制<code>ApplicationContext</code>的类型</li></ol><h6 id="（5）获取应用参数（ApplicationArguments）"><a href="#（5）获取应用参数（ApplicationArguments）" class="headerlink" title="（5）获取应用参数（ApplicationArguments）"></a>（5）获取应用参数（<code>ApplicationArguments</code>）</h6><p>如果想访问传递给<code>SpringApplication.run(...)</code>的参数，可以注入<code>（@Autowired）</code>一个<code>org.springframework.boot.ApplicationArguments</code><br>Bean:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBean&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public MyBean(ApplicationArguments args)&#123;</span><br><span class="line">        boolean debug &#x3D; args.containsOption(&quot;debug&quot;);</span><br><span class="line">        List&lt;String&gt; files &#x3D; args.getNonOptionArgs();</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="（6）ApplicationRunner-CommandLineRunner"><a href="#（6）ApplicationRunner-CommandLineRunner" class="headerlink" title="（6）ApplicationRunner/CommandLineRunner"></a>（6）<code>ApplicationRunner/CommandLineRunner</code></h6><p>如果想在<code>SpringApplication</code>已启动就运行特定代码，可以引用<code>ApplicationRunner/CommandLineRunner</code>接口，两个接口都只提供一个<code>run()</code>方法，一旦<code>SpringApplication.run(...)</code>运行结束就被调用。</p><ol><li><code>ApplicationRunner</code>传入<code>ApplicationArguments</code>实例作为参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBean implements ApplicationRunner&#123;</span><br><span class="line">    public void run(ApplicatioArguments args)&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>CommandLineRunner传入String数组作为参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyBean implements CommandLineRunner&#123;</span><br><span class="line">    public void run(String... args)&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h5 id="【2】外部化配置"><a href="#【2】外部化配置" class="headerlink" title="【2】外部化配置"></a>【2】外部化配置</h5><p><code>SpringBoot</code>允许通过<code>application.properties</code>/<code>application.yml</code>/环境变量/命令行参数将配置外部化，通过<code>@Value</code>/<code>Environment</code>/<code>@ConfigurationProperties</code>可以直接注入属性值。<br><strong>随机值</strong><br><code>RandomValuePropertySource</code>可以生产随机的属性值，用于注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my.secret&#x3D;$&#123;random.value&#125;</span><br><span class="line">my.number&#x3D;$&#123;random.int&#125;</span><br><span class="line">my.bignumber&#x3D;$&#123;random.long&#125;</span><br><span class="line">my.uuid&#x3D;$&#123;random.uuid&#125;</span><br><span class="line">my.number.less.than.ten&#x3D;$&#123;random.int(10)&#125;</span><br><span class="line">my.number.in.range&#x3D;$&#123;random.int[1024,65536]&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="【3】根据环境切换配置文件"><a href="#【3】根据环境切换配置文件" class="headerlink" title="【3】根据环境切换配置文件"></a>【3】根据环境切换配置文件</h5><ol><li><code>@Profile(&quot;xxx&quot;)</code>：加在<code>@Component/@Configuration</code>上可以指定属性生效的环境<blockquote><p>@Configuration<br>@Profile(“prod”)<br>public class ProdConfiguration{<br> //生产环境配置<br>}</p></blockquote></li><li><code>spring.profile.active</code>：配置在<code>application.properties/application.yml</code>中，可以设置生效的配置文件（比如<code>application-prod.yml</code>）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profile.avtive&#x3D;prod,pre</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：在<code>application-prod.yml</code>中要加<code>spring.profiles</code>属性指明配置文件的名称！</strong></p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    profiles: prod</span><br><span class="line"># 添加其他配置</span><br><span class="line"># spring.profiles.include:</span><br><span class="line">#   - proddb</span><br><span class="line">#   - prodmq</span><br></pre></td></tr></table></figure><ol start="3"><li><code>--spring.profile.avtive=prod,pre</code>：加在命令行后</li><li><code>SpringApplication.setAdditionalProfiles(...)</code>：加在程序中</li></ol><hr><h5 id="【4】日志"><a href="#【4】日志" class="headerlink" title="【4】日志"></a>【4】日志</h5><ul><li><code>Spring Boot</code>内部日志默认使用的是<code>Apache Commons Logging</code>，但是也提供了<code>Java Util Logging/Log4J2/Logback</code>的默认配置，默认使用控制台输出，可以配置为使用文件输出。</li><li>如果使用starters，默认日志是<code>Logback</code>。</li></ul><p><strong>日志格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-03-05 10:57:51.112  INFO 45469 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet Engine: Apache Tomcat&#x2F;7.0.52</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.a.c.c.C.[Tomcat].[localhost].[&#x2F;]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2019-03-05 10:57:51.253  INFO 45469 --- [ost-startStop-1] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 1358 ms</span><br><span class="line">2019-03-05 10:57:51.698  INFO 45469 --- [ost-startStop-1] o.s.b.c.e.ServletRegistrationBean        : Mapping servlet: &#39;dispatcherServlet&#39; to [&#x2F;]</span><br><span class="line">2019-03-05 10:57:51.702  INFO 45469 --- [ost-startStop-1] o.s.b.c.embedded.FilterRegistrationBean  : Mapping filter: &#39;hiddenHttpMethodFilter&#39; to: [&#x2F;*]</span><br></pre></td></tr></table></figure><ol><li>日期、时间（<code>ms</code>级别），方便排序</li><li>日志级别：<code>INFO</code>、<code>ERROR</code>、<code>WARN</code>、<code>TRACE</code>、<code>DEBUG</code></li><li><strong>进程ID</strong></li><li>分隔符<code>---</code>：标明实际日志内容开始</li><li><strong>使用[]包起来的线程名称</strong></li><li>记录器名称：<strong>一般是记录日志的类名</strong></li><li>日志信息</li></ol><p><strong>输出<code>DEBUG/TRACE</code>日志</strong><br>默认情况下，只有<code>ERROR/WARN/INFO</code>级别的日志会输出，想要输出<code>DEBUG/TRACE</code>日志可以有以下几种方法：</p><ol><li>命令行启动应用时使用：<code>java -jar xx.jar --debug</code>或<code>java -jar xx.java --trace</code></li><li><code>application.properties</code>中加：<code>debug=true</code>或<code>trace=true</code></li></ol><p><strong>将日志输出到文件</strong></p><ul><li>在<code>application.properties</code>文件中添加<code>logging.file/logging.path</code>属性，可以将日志输出到文件</li><li>默认只会输出<code>INFO/ERROR/WARN</code>级别的日志</li><li>日志文件默认最大<code>10MB</code>，超过<code>10MB</code>会被截断，产生新的日志文件，可以通过<code>logging.file.max-size</code>进行配置</li></ul><hr><h5 id="【5】验证（-Validated）"><a href="#【5】验证（-Validated）" class="headerlink" title="【5】验证（@Validated）"></a>【5】验证（@Validated）</h5><ul><li>通过<code>javax.validation</code>可以对方法的参数/返回值进行验证</li><li><strong>在需要验证的类上要加<code>@Validated</code>注解</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;需要验证的类要加@Validated注解</span><br><span class="line">@Validated</span><br><span class="line">@Bean</span><br><span class="line">public class MyBean&#123;</span><br><span class="line">    &#x2F;&#x2F;通过@Size(min,max)注解验证第一个参数，保证其值在8-10之间</span><br><span class="line">    public Archive findByCodeAndAuthor(@Size(min &#x3D; 8, max &#x3D; 10) String code,</span><br><span class="line">        Author author)&#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h5 id="【6】部署"><a href="#【6】部署" class="headerlink" title="【6】部署"></a>【6】部署</h5><h6 id="将应用安装为服务"><a href="#将应用安装为服务" class="headerlink" title="将应用安装为服务"></a>将应用安装为服务</h6><p>除了使用<code>java -jar</code>来运行<code>Spring Boot</code>应用外，也可以将应用注册到<code>init.d</code>或<code>systemd</code>成为服务。<br>使用<code>init.d</code>的步骤</p><ol><li><p>添加<code>Maven</code>打包依赖：</p></li><li><p><code>mvn package</code>后发送到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;plugin&gt; </span><br><span class="line">    &lt;groupId&gt; org.springframework.boot &lt;&#x2F; groupId&gt; </span><br><span class="line">    &lt;artifactId&gt; spring-boot-maven-plugin &lt;&#x2F; artifactId&gt; </span><br><span class="line">    &lt;configuration&gt; </span><br><span class="line">        &lt;executable&gt; true &lt;&#x2F; executable&gt; </span><br><span class="line">    &lt;&#x2F; configuration&gt; </span><br><span class="line">&lt;&#x2F; plugin&gt;</span><br></pre></td></tr></table></figure></li><li><p>注册服务，并设置为<strong>开机自启动</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;var&#x2F;myapp&#x2F;myapp.jar &#x2F;etc&#x2F;init.d&#x2F;myapp</span><br></pre></td></tr></table></figure></li><li><p>启动服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;var&#x2F;myapp&#x2F;myapp.jar &#x2F;etc&#x2F;init.d&#x2F;myapp</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> spring系列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/2019/11/27/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/11/27/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h3><a id="more"></a><hr><h5 id="（一）安装-amp-启动"><a href="#（一）安装-amp-启动" class="headerlink" title="（一）安装 &amp; 启动"></a>（一）安装 &amp; 启动</h5><p>&nbsp;&nbsp;&nbsp;1. <a href="https://www.cnblogs.com/kingsonfu/p/9819657.html" target="_blank" rel="noopener">阿里云安装</a><br>&nbsp;&nbsp;&nbsp;2. 在<code>Docker ubuntu</code>镜像中安装<code>Redis</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker attach 241b</span><br><span class="line">apt-get update</span><br><span class="line">apt-get -y install redis-server</span><br><span class="line">&#x2F;etc&#x2F;inti.d&#x2F;redis-server restart</span><br><span class="line">redis-cli     #启动Redis客户端</span><br></pre></td></tr></table></figure><p><code>Redis</code>默认端口号是<code>6379</code>，出于好奇搜了一下为什么是<code>6379</code>，然后发现了作者写的一篇文章，大致意思是说<code>6379</code>在手机9键上是MERZ，是意大利的一个女明星，作者认为她是“stupid”的代名词……然后作者还说你一定会好奇MERZ是谁，不过劝你不要上班查，因为not safe for work，然后我处于好奇搜了一下……<a href="http://blog.sina.cn/dpool/blog/s/blog_6638c1940102x3om.html" target="_blank" rel="noopener">后台硬的可以看看我搜到了什么</a>…… - -|||</p><hr><h5 id="（二）基础命令"><a href="#（二）基础命令" class="headerlink" title="（二）基础命令"></a>（二）基础命令</h5><blockquote><p><a href="https://redis.io/commands" target="_blank" rel="noopener">所有</a><code>Redis</code><a href="https://redis.io/commands" target="_blank" rel="noopener">命令查询</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;1. 存储键值对：<code>SET key value</code><br>&nbsp;&nbsp;&nbsp;2. 根据键读取值：<code>GET key</code><br>&nbsp;&nbsp;&nbsp;3. 长度：<code>STRLEN key</code><br>&nbsp;&nbsp;&nbsp;4. 批量存储键值对：<code>MSET key1 value1 key2 value2</code>…<br>&nbsp;&nbsp;&nbsp;5. 根据键批量读取值：<code>MGET key1 key2</code>…<br>&nbsp;&nbsp;&nbsp;6. Hash存储：<code>HSET key field value</code><br>&nbsp;&nbsp;&nbsp;7. Hash读取：<code>HGET key field</code><br>&nbsp;&nbsp;&nbsp;8. 批量Hash存储：<code>HMSET key field1 value1 field2 value2</code>…<br>&nbsp;&nbsp;&nbsp;9. 批量Hash读取：<code>HGETALL key</code><br>&nbsp;&nbsp;&nbsp;10. 设置过期时间：<code>EXPIRE key seconds</code><br>&nbsp;&nbsp;&nbsp;11. 返回所有给定模式pattern的key：<code>KEYS pattern</code></p><blockquote><p>比如：<br>①<code>KEYS</code> ：返回所有<code>key；</code><br>②<code>KEYS h?llow</code>：匹配<code>hallow/hbllow/…；</code><br>③<code>KEYS hllow</code>：匹配<code>hallow/hbbllow/hccccllow/…；</code><br>④<code>KEYS h[ae]llow</code>：匹配<code>hallow/hellow</code></p></blockquote><p>&nbsp;&nbsp;&nbsp;12. 基于游标的迭代器：<code>SCAN cursor [MATCH pattern] [COUNT cnt]</code></p><blockquote><p><code>SCAN 0</code>：<strong>新开始一次迭代，返回下一次迭代应该开始的位置；</strong></p></blockquote><p><code>SCAN</code>返回的结果为0时，表示迭代已经结束。</p><blockquote><p><code>keys</code>和<code>sca</code>n时间复杂度都是O(N)，但是不同的是<code>keys</code>会阻塞遍历整个<code>Redis</code>，在海量数据时会很严重的性能问题；而<code>scan</code>采取的是增量迭代模式，不会阻塞整个<code>Redis</code>。</p></blockquote><p>&nbsp;&nbsp;&nbsp;13. 清空当前数据库中的所有key：<code>flushDB</code></p><hr><h5 id="三）Redis-对象类型-amp-数据结构"><a href="#三）Redis-对象类型-amp-数据结构" class="headerlink" title="三）Redis 对象类型 &amp; 数据结构"></a>三）Redis 对象类型 &amp; 数据结构</h5><p><code>Redis</code>核心对象<code>redisObject</code>：<br>&nbsp;&nbsp;&nbsp;1. 数据类型<code>type</code>：表示一个value对象具体是哪种数据类型，包括<code>string/hash/list/set/sorted set</code><br>&nbsp;&nbsp;&nbsp;2. 编码方式<code>encoding</code>：<code>raw/int/ht/zipmap/linkedlist/ziplist/intset</code><br>&nbsp;&nbsp;&nbsp;3. 数据指针<code>ptr</code><br>&nbsp;&nbsp;&nbsp;4. 虚拟内存<code>vm</code><br>&nbsp;&nbsp;&nbsp;5. 其他信息 </p><h5 id="1-String：简单动态字符串SDS"><a href="#1-String：简单动态字符串SDS" class="headerlink" title="1. String：简单动态字符串SDS"></a>1. String：简单动态字符串SDS</h5>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> NoSql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA Mybatis逆向生成</title>
      <link href="/2019/11/25/IDEA%20Mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90/"/>
      <url>/2019/11/25/IDEA%20Mybatis%E9%80%86%E5%90%91%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA的逆向生成步骤要与Eclipse的逆向生成不一样，记录一下"><a href="#IDEA的逆向生成步骤要与Eclipse的逆向生成不一样，记录一下" class="headerlink" title="IDEA的逆向生成步骤要与Eclipse的逆向生成不一样，记录一下"></a>IDEA的逆向生成步骤要与Eclipse的逆向生成不一样，记录一下</h3><p><img src="http://5b0988e595225.cdn.sohucs.com/q_70,c_zoom,w_640/images/20190417/fe4664b0269949169461087d6553b7cc.jpeg" alt></p><a id="more"></a><h2 id="（一）pom文件引入依赖"><a href="#（一）pom文件引入依赖" class="headerlink" title="（一）pom文件引入依赖"></a>（一）pom文件引入依赖</h2><p>基本依赖：mysql、jdbc、mybatis、druid、web<br>注：要小心版本冲突！！<br><img src="https://i.loli.net/2020/02/23/hwQl7bZ89sduO23.png" alt><br><img src="https://i.loli.net/2020/02/23/LCKditrzpYqm1GE.png" alt></p><hr><h2 id="（二）application-yml"><a href="#（二）application-yml" class="headerlink" title="（二）application.yml"></a>（二）application.yml</h2><p>application中增加数据库和连接池的链接信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8089</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3307&#x2F;school</span><br><span class="line">    username: root</span><br><span class="line">    password: 数据库密码</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    druid:</span><br><span class="line">      initial-size: 50</span><br><span class="line">      min-idle: 20</span><br><span class="line">      max-active: 100</span><br><span class="line">      max-wait: 60000</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      validation-query: SELECT 1</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      test-on-borrow: false</span><br><span class="line">      test-on-return: false</span><br></pre></td></tr></table></figure><hr><h2 id="（三）resources文件夹中增加xml文件"><a href="#（三）resources文件夹中增加xml文件" class="headerlink" title="（三）resources文件夹中增加xml文件"></a>（三）resources文件夹中增加xml文件</h2><p><img src="https://i.loli.net/2020/02/23/LCKditrzpYqm1GE.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;generatorConfiguration&gt;</span><br><span class="line">    &lt;!-- 配置mysql 驱动jar包路径.用了绝对路径 --&gt;</span><br><span class="line">    &lt;classPathEntry</span><br><span class="line">            location&#x3D;&quot;E:&#x2F;&#x2F;mvn_repository&#x2F;reps&#x2F;mysql&#x2F;mysql-connector-java&#x2F;5.1.47&#x2F;mysql-connector-java-5.1.47.jar&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;context id&#x3D;&quot;scm_mysql_tables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt;</span><br><span class="line">        &lt;!-- 防止生成的代码中有很多注释，加入下面的配置控制 --&gt;</span><br><span class="line">        &lt;commentGenerator&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;suppressDate&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;commentGenerator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 数据库连接 --&gt;</span><br><span class="line">        &lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.jdbc.Driver&quot;</span><br><span class="line">                        connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3307&#x2F;school?characterEncoding&#x3D;UTF-8&quot;</span><br><span class="line">                        userId&#x3D;&quot;root&quot;</span><br><span class="line">                        password&#x3D;&quot;密码&quot;&gt;</span><br><span class="line">        &lt;&#x2F;jdbcConnection&gt;</span><br><span class="line"></span><br><span class="line">        &lt;javaTypeResolver&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaTypeResolver&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 配置 pojo 实体类文件所在项目及包路径 --&gt;</span><br><span class="line">        &lt;javaModelGenerator targetPackage&#x3D;&quot;com.xdclass.demo.pojo&quot;</span><br><span class="line">                            targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaModelGenerator&gt;</span><br><span class="line">        &lt;!-- 配置Mapper接口所在的项目及包路径 --&gt;</span><br><span class="line">        &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.xdclass.demo.mapper&quot;</span><br><span class="line">                         targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;sqlMapGenerator&gt;</span><br><span class="line">        &lt;!-- 配置常规功能单元（工具类）所在的项目及包路径，包括xml文件等插件 --&gt;</span><br><span class="line">        &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot;</span><br><span class="line">                             targetPackage&#x3D;&quot;com.xdclass.demo.mapper&quot;</span><br><span class="line">                             targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;</span><br><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;javaClientGenerator&gt;</span><br><span class="line">        &lt;!-- 数据表进行生成操作 schema:相当于库名; tableName:表名;</span><br><span class="line">            domainObjectName:对应的DO</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;table tableName&#x3D;&quot;%&quot;&gt;</span><br><span class="line">        &lt;&#x2F;table&gt;</span><br><span class="line">    &lt;&#x2F;context&gt;</span><br><span class="line">&lt;&#x2F;generatorConfiguration&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="（四）pom文件增加build依赖"><a href="#（四）pom文件增加build依赖" class="headerlink" title="（四）pom文件增加build依赖"></a>（四）pom文件增加build依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.5&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;verbose&gt;true&lt;&#x2F;verbose&gt;</span><br><span class="line">                &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src&#x2F;main&#x2F;java&lt;&#x2F;directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**&#x2F;*.xml&lt;&#x2F;include&gt;</span><br><span class="line">            &lt;&#x2F;includes&gt;</span><br><span class="line">        &lt;&#x2F;resource&gt;</span><br><span class="line">    &lt;&#x2F;resources&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="（五）使用maven自动生成"><a href="#（五）使用maven自动生成" class="headerlink" title="（五）使用maven自动生成"></a>（五）使用maven自动生成</h2><p><img src="https://i.loli.net/2020/02/23/G5yNkOUqwEJXigZ.png" alt><br>控制台出现<br><img src="https://i.loli.net/2020/02/23/aI1dGmy98UAi3qC.png" alt><br>即生成成功<br>注：生成的实体类是没加序列化，不要忘记implements Serializable。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub小技巧</title>
      <link href="/2019/11/22/GitHub%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/11/22/GitHub%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p><img src="http://gss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/bba1cd11728b471049731910c5cec3fdfd03238a.jpg" alt></p><a id="more"></a><h3 id="GitHub小技巧"><a href="#GitHub小技巧" class="headerlink" title="GitHub小技巧"></a>GitHub小技巧</h3><hr><h2 id="（一）快捷键查看：shift"><a href="#（一）快捷键查看：shift" class="headerlink" title="（一）快捷键查看：shift + ?"></a>（一）快捷键查看：shift + ?</h2><p>在任意界面输入shift + ?，可以显示快捷键。</p><hr><h2 id="（二）查看自己项目的访问数据：Insights-Traffic"><a href="#（二）查看自己项目的访问数据：Insights-Traffic" class="headerlink" title="（二）查看自己项目的访问数据：Insights - Traffic"></a>（二）查看自己项目的访问数据：Insights - Traffic</h2><p>在自己的项目下，点击Insights-Traffic，里面有Referring sites（代表大家从什么网页来到你的项目）和Popular content（代表大家经常看你项目的什么文件）。<br><img src="https://dragonbaby308.oss-cn-hangzhou.aliyuncs.com/git/github/shortcut.png" alt></p><hr><h2 id="（三）编辑代码"><a href="#（三）编辑代码" class="headerlink" title="（三）编辑代码"></a>（三）编辑代码</h2><p>在查看任意文件时，右上角会有一个小铅笔的标识。<br><img src="https://dragonbaby308.oss-cn-hangzhou.aliyuncs.com/git/github/pen.png" alt><br>点击小铅笔就可以直接编辑文件，编辑完成后，直接在页面上点击Propose File Change，Github就会为你fork这个仓库，创建一个pull request，节省了在本地fork -&gt; pull -&gt; 修改 -&gt; push -&gt; 创建PR的过程。</p><hr><h2 id="（四）趋势图——https-octoverse-github-com"><a href="#（四）趋势图——https-octoverse-github-com" class="headerlink" title="（四）趋势图——https://octoverse.github.com/"></a>（四）趋势图——<a href="https://octoverse.github.com/" target="_blank" rel="noopener">https://octoverse.github.com/</a></h2><p>Github语言趋势图：<a href="https://octoverse.github.com/" target="_blank" rel="noopener">https://octoverse.github.com/</a></p><hr><h2 id="（五）精确搜索项目"><a href="#（五）精确搜索项目" class="headerlink" title="（五）精确搜索项目"></a>（五）精确搜索项目</h2><p>in:name keyWord：项目名中含有keyWord<br>in:readme keyWord：项目README.md中含有keyWord<br>in:description keyWord：项目描述中含有keyWord<br>stars:&gt;N：星星数量大于N<br>language:Golang：语言限定为Golang语言<br>pushed:&gt;2019-06-06：最后一次提交时间晚于2019-06-06<br>比如我想搜索Golang语言微服务项目，最后一次提交时间要晚于2019-06-06，星星数量大于1000个：<br>in:description 微服务 language:go pushed:&gt;2019-06-06 stars:&gt;1000</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim使用教程</title>
      <link href="/2019/11/04/vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/04/vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vim使用教程"><a href="#vim使用教程" class="headerlink" title="vim使用教程"></a>vim使用教程</h2><p>本文先概述什么是vim以及为什么要学习vim，然后介绍vim的基础操作（包括normal模式、编辑模式、命令模式、可视化模式这4个模式，以及3个模式下的一些基础命令），最后介绍如何通过插件使你的vim赏心悦目。</p><a id="more"></a><hr><h3 id="vim简介"><a href="#vim简介" class="headerlink" title="vim简介"></a>vim简介</h3><h5 id="1-什么是vim？"><a href="#1-什么是vim？" class="headerlink" title="1.什么是vim？"></a>1.什么是vim？</h5><p>vim是Linux/Unix下的文本编辑器，类似于记事本，是vi的改进版本，纯键盘友好。</p><h5 id="2-为什么要学习vim？"><a href="#2-为什么要学习vim？" class="headerlink" title="2.为什么要学习vim？"></a>2.为什么要学习vim？</h5><p>后端免不了和服务器打交道，而服务器往往需要24 x 7 x 365，所以稳定的Linux服务器成了首选。在Linux服务器上没有记事本，只有vim文本编辑器；且服务器往往不配备鼠标，所以纯键盘友好的vim编辑器是最佳选择。简单来说，不会基础的vim操作，在Linux服务器上寸步难行。</p><h5 id="3-命令帮助"><a href="#3-命令帮助" class="headerlink" title="3.命令帮助"></a>3.命令帮助</h5><p><code>:help commandName</code></p><hr><h3 id="vim的4个模式及基本命令"><a href="#vim的4个模式及基本命令" class="headerlink" title="vim的4个模式及基本命令"></a>vim的4个模式及基本命令</h3><h5 id="1-normal模式"><a href="#1-normal模式" class="headerlink" title="1.normal模式"></a>1.normal模式</h5><p>normal模式是vim的默认模式，也就是通过vim filename命令打开文件时最初始的模式，只可以浏览，不可用编辑。如图：<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3h0s4g2lwj30b00net8r.jpg" alt><br>在编辑模式/命令模式下，想要退回到normal模式，只需要按<code>esc</code>或<code>ctrl+[</code> 即可。<br>常用命令有:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 移动</span><br><span class="line">w           #word，移动到下一个单词开头</span><br><span class="line">b           #backward，移动到上一个单词开头</span><br><span class="line">0           #移动到行首</span><br><span class="line">$           #移动到行尾</span><br><span class="line">gg          #移动到文件开头</span><br><span class="line">G           # 【移动到文件结尾】！！！</span><br><span class="line">ctrl + u    #向上翻页</span><br><span class="line">ctrl + f    #向下翻页</span><br><span class="line">zz          #将当前行置到屏幕中间</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">x           #删除某个字符</span><br><span class="line">dd          #删除行</span><br><span class="line"></span><br><span class="line"># 修改</span><br><span class="line">r           #replace，r后接字符，可以快速将光标处字符替换为r后的字符</span><br><span class="line">s           #substitute，删除光标处字符，并进入插入模式</span><br><span class="line">C           #删除整行，并进入插入模式</span><br><span class="line"></span><br><span class="line"># 查找</span><br><span class="line">&#x2F;           #查找&#x2F;后的字符，按n可以向后匹配</span><br><span class="line"></span><br><span class="line">u           #undo，回退</span><br></pre></td></tr></table></figure><h5 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2.编辑模式"></a>2.编辑模式</h5><p>在normal模式下通过如下命令进入编辑模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gi  #快速回到上次编辑位置</span><br><span class="line">i   #insert，在光标后插入</span><br><span class="line">a   #append，在光标前插入</span><br><span class="line">o   #open a line below，在光标下一行插入</span><br><span class="line">I   #在当前行末尾插入</span><br><span class="line">A   #在当前行开头插入</span><br><span class="line">O   #OPEN A LINE ABOVE，在光标上一行插入</span><br></pre></td></tr></table></figure><p>编辑模式下的常用vim命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除</span><br><span class="line">ctrl + h    #删除上一个字符</span><br><span class="line">ctrl + w    #删除上一个单词</span><br><span class="line">ctrl + h    #删除上一行</span><br></pre></td></tr></table></figure><h5 id="3-命令模式"><a href="#3-命令模式" class="headerlink" title="3.命令模式"></a>3.命令模式</h5><p>在normal模式/编辑模式下通过命令:进入，键入命令即可：<br><code>wq</code>：write quit，保存退出<br><code>set nu</code> ：set number，设置行号<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3h168bxb8j30ar0mnt8o.jpg" alt><br><code>sp</code>：split，水平分屏。如需退出，使用:q即可。如需切换屏幕，使用<code>ctrl + ww</code>即可。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3h19gcp6gj30e10mj0sp.jpg" alt><br><code>%s/str1/str2/g</code>：全局替换，将字符串str1替换为str2<br><code>syntax on</code>：开启语法高亮</p><h5 id="4-可视化模式"><a href="#4-可视化模式" class="headerlink" title="4.可视化模式"></a>4.可视化模式</h5><p>为了方便<strong>选取文本</strong>，vim引入类可视化（visual）模式，该模式下可以进行<strong>全局操作</strong>和<strong>块状选择</strong>。在normal模式下通过执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v         #行内选择字符</span><br><span class="line">V         #选中一行</span><br><span class="line">ctrl + v  #Visual Block，块状选择</span><br><span class="line">d         #delete，删除</span><br><span class="line">y         #yank，复制</span><br></pre></td></tr></table></figure><hr><h3 id="vim配置文件-vimrc"><a href="#vim配置文件-vimrc" class="headerlink" title="vim配置文件~/.vimrc"></a>vim配置文件<code>~/.vimrc</code></h3><p>vim配置文件是用户目录（~）下的隐藏文件（.），通过命令<code>vim ~/.vimrc</code>即可打开，可以对vim进行一系列<strong>持久化</strong>的配置。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;vim注释采用单个引号</span><br><span class="line">set backspace&#x3D;2         &quot;可随时用退格键删除</span><br><span class="line">set nu &quot;设置行号，nu(mber)</span><br><span class="line">set cursorline  &quot;光标所在行高亮</span><br><span class="line">set ruler&quot;在状态栏显示光标的当前位置</span><br><span class="line">set showmode &quot;在底部显示，当前处于命令模式&#x2F;插入模式</span><br><span class="line">set showcmd&quot;命令模式下，在底部显示当前键入的命令</span><br><span class="line">set showmatch&quot;光标遇到圆括号、方括号、大括号时，自动高亮显示匹配的另一个括号</span><br><span class="line">set incsearch&quot;输入模式搜索时，每输入一个字符，就自动跳到第一个匹配的结果</span><br><span class="line">set hlsearch &quot;高亮（high light）搜索</span><br><span class="line">set foldmethod&#x3D;indent &quot;设置折叠方式</span><br><span class="line">set wrap &quot;自动拆行，太长的行分为几行显示</span><br><span class="line">set visualbell  &quot;出错时发出视觉提示，一般是屏幕闪烁</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础知识</title>
      <link href="/2019/10/28/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/10/28/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h3><h5 id="1-Constructor可以重写吗？"><a href="#1-Constructor可以重写吗？" class="headerlink" title="1.Constructor可以重写吗？"></a>1.<code>Constructor</code>可以重写吗？</h5><p><code>Constructor</code>不允许重写<code>@Override</code>，但是可以重载<code>（overload）</code>。</p><a id="more"></a><hr><h5 id="2-重写（-Override）-amp-重载（overload）"><a href="#2-重写（-Override）-amp-重载（overload）" class="headerlink" title="2.重写（@Override） &amp; 重载（overload）"></a>2.重写<code>（@Override）</code> &amp; 重载<code>（overload）</code></h5><ul><li>重写<code>@Override</code>：发生在<strong>父子类</strong>中，函数名、参数列表必须相同，子类返回值范围必须小于等于父类返回值，子类抛出异常范围必须小于等于父类，子类访问修饰符必须大于等于父类<blockquote><p><strong>父类的<code>private</code>、<code>final</code>、<code>Construnctor</code>函数不允许被重写</strong></p></blockquote></li><li>重载（overload）：发生在<strong>同一类</strong>中，函数名必须相同，参数列表、返回值、修饰符可以不同。</li></ul><hr><h5 id="3-String-amp-StringBuilder-amp-StringBuffer"><a href="#3-String-amp-StringBuilder-amp-StringBuffer" class="headerlink" title="3.String &amp; StringBuilder &amp; StringBuffer"></a>3.<code>String</code> &amp; <code>StringBuilder</code> &amp; <code>StringBuffer</code></h5><p>&nbsp;&nbsp;&nbsp;1.可变性：<code>String</code>是不可变的，<code>StringBuilder</code>和<code>StringBuffer</code>都是可变的</p><blockquote><p><strong><code>String</code>内部采用<code>final</code>类型的数组存储字符串，所以是不可变的。</strong><br><code>StringBuilder</code>和<code>StringBuffer</code>内部用于存储字符串的数组都不是<code>final</code>的。</p></blockquote><p>&nbsp;&nbsp;&nbsp;2.线程安全性：<code>String</code>由于是不可变的，所以天生线程安全；<code>StringBuilder</code>不是线程安全的；<code>StringBuffer</code>通过同步锁保证了线程安全<br>&nbsp;&nbsp;&nbsp;3. 性能：<code>StringBuilder</code>比<code>StringBuffer</code>性能要优10%~15%，但是线程不安全；<code>String</code><strong>每次修改是指向新的对象，而<code>StringBuilder</code>则是每次操作原有对象</strong></p><h5 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h5><p>&nbsp;&nbsp;&nbsp;1.操作少量字符串：<code>String</code><br>&nbsp;&nbsp;&nbsp;2.<strong>单线程</strong>操作大量字符串：<code>StringBuilder</code><br>&nbsp;&nbsp;&nbsp;3.<strong>多线程</strong>操作大量字符串：<code>StringBuffer</code></p><hr><h5 id="4-接口（public-interface）-amp-抽象类（abstract-class）"><a href="#4-接口（public-interface）-amp-抽象类（abstract-class）" class="headerlink" title="4.接口（public interface） &amp; 抽象类（abstract class）"></a>4.接口<code>（public interface）</code> &amp; 抽象类<code>（abstract class）</code></h5><p>&nbsp;&nbsp;&nbsp;1.接口必须是<code>public</code>的，抽象类除了<code>private</code>都可以<br>&nbsp;&nbsp;&nbsp;2.接口变量必须是<code>final</code>、<code>static</code>的，抽象类则不一定</p><blockquote><p>接口变量必须是<code>static</code>的，但是接口本身不能是<code>static</code>的</p></blockquote><p>&nbsp;&nbsp;&nbsp;3.性能：<code>StringBuilder</code>比<code>StringBuffer</code>性能要优10%~15%，但是线程不安全；<code>String</code><strong>每次修改是指向新的对象，而<code>StringBuilder</code>则是每次操作原有对象</strong></p><hr><h5 id="5-使用常量或有确定值的对象调用equals"><a href="#5-使用常量或有确定值的对象调用equals" class="headerlink" title="5.使用常量或有确定值的对象调用equals()"></a>5.使用常量或有确定值的对象调用equals()</h5><p><strong>如果通过<code>null</code>调用<code>equals()</code>会导致<code>NullPointerException</code>，所以如果要调用<code>equals()</code>，那么最好是常量，或者对象一定非<code>null</code>。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s &#x3D; null;</span><br><span class="line">if(s.equals(&quot;xxxx&quot;) ) &#123;...&#125; &#x2F;&#x2F;NullPointerException</span><br><span class="line">if(&quot;xxxx&quot;.equals(s) ) &#123;...&#125; &#x2F;&#x2F;通过常量调用</span><br></pre></td></tr></table></figure><p><strong>推荐直接使用工具类<code>java.util.Objects</code>的<code>equals()</code>方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(Objects.equals(s, &quot;xxxx&quot;) )&#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-a-和-a的区别"><a href="#6-a-和-a的区别" class="headerlink" title="6.a++和++a的区别"></a>6.a++和++a的区别</h5><ul><li>a++是先使用a，使用完后再a = a + 1</li><li>++a是先让a + 1，再使用a的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int a &#x3D; 10 &gt;&gt; 1;    &#x2F;&#x2F;a &#x3D; 5</span><br><span class="line">int b &#x3D; a++;        &#x2F;&#x2F;先使用a的原值，所以b &#x3D; 5，然后a + 1， a &#x3D; 6</span><br><span class="line">int c &#x3D; ++a;        &#x2F;&#x2F;先让a + 1，a &#x3D; 7，c &#x3D; 7</span><br><span class="line">int d &#x3D; b * a++;    &#x2F;&#x2F;先使用a的旧值，d &#x3D; 5 * 7 &#x3D; 35，然后a + 1，a&#x3D; 8</span><br><span class="line">System.out.println(a);  &#x2F;&#x2F;8</span><br><span class="line">System.out.println(b);  &#x2F;&#x2F;5</span><br><span class="line">System.out.println(c);  &#x2F;&#x2F;7</span><br><span class="line">System.out.println(d);  &#x2F;&#x2F;35</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x2F;&#x2F;i，j均为数组下标</span><br><span class="line"></span><br><span class="line">map.add(string.charAt(j++));</span><br><span class="line">&#x2F;&#x2F;等价于：</span><br><span class="line">&#x2F;&#x2F;map.add(string.charAt(j));</span><br><span class="line">&#x2F;&#x2F;j &#x3D; j + 1;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
